# 5. Smart Contracts

## 5.1 Overview

The AI-G-DAO smart contract system is built on the Algorand blockchain using Python and the AlgoKit framework. Our contracts provide the foundation for democratic governance, transparent proposal management, and automated Climate Impact Credit (CIC) distribution while maintaining carbon-negative operations.

**Live Deployment**: The smart contract is currently deployed on Algorand TestNet with Contract ID: `744174033`, providing real-time voting capabilities and transaction tracking through Lora Explorer integration.

## 5.2 Contract Architecture

### 5.2.1 Live Deployment Information

#### Current Deployment Status
- **Contract ID**: 744174033 (Algorand TestNet)
- **Network**: Algorand TestNet (carbon-negative blockchain)
- **Transaction Explorer**: https://lora.algokit.io/testnet/transaction/
- **Voting Cost**: 0.001 ALGO per vote transaction
- **Deployment Framework**: AlgoKit with Python/Puya compiler
- **Status**: Active and processing real transactions

## 5.2 Contract Architecture

### 5.2.2 Project Structure

```
contracts/climate-dao/
├── climate-dao.code-workspace
├── README.md
└── projects/
    └── climate-dao/
        ├── poetry.lock
        ├── poetry.toml
        ├── pyproject.toml
        ├── README.md
        └── smart_contracts/
            ├── __init__.py
            ├── __main__.py                  # Deployment entry point
            └── climate_dao/
                ├── contract.py              # Main contract logic
                ├── state.py                 # State management
                ├── operations.py            # Core operations
                └── governance.py            # Governance functions
```

### 5.2.3 Development Environment

#### Dependencies
```toml
[tool.poetry.dependencies]
python = "^3.12"
algokit-utils = "^2.0.0"
algosdk = "^2.0.0"
puyapy = "^1.0.0"

[tool.poetry.group.dev.dependencies]
algokit-client-generator = "^1.0.0"
pytest = "^7.0.0"
pytest-cov = "^4.0.0"
```

#### AlgoKit Configuration
- **Framework**: AlgoKit for standardized development and deployment
- **Language**: Python with Puya compiler for optimal performance
- **Network**: Algorand TestNet (production-ready for MainNet migration)
- **Deployment**: Automated deployment scripts with live contract management
- **Transaction Fees**: Minimal 0.001 ALGO fees for democratic accessibility
- **Contract Size**: Optimized for Algorand's 8KB contract limit

## 5.3 Storage Constraints and Limitations

### 5.3.1 Algorand Blockchain Constraints

#### Smart Contract Storage Limits
- **Contract Size**: Maximum 8KB for compiled contract code
- **Global State**: 64 key-value pairs maximum per application
- **Local State**: 16 key-value pairs maximum per user account
- **Key Length**: Maximum 64 bytes per state key
- **Value Length**: Maximum 128 bytes per state value
- **Transaction Note**: Maximum 1KB for additional data

#### Data Storage Strategies
- **Proposal Metadata**: Stored in global state with compressed format
- **Large Data**: Off-chain storage with on-chain hash verification
- **User History**: Local state tracking with periodic archival
- **Vote Records**: Efficient bitmap storage for vote tracking
- **AI Analysis**: Compressed summary scores on-chain, full analysis off-chain

### 5.3.2 Current Implementation Constraints

#### Active Storage Utilization
- **Global State Usage**: ~45/64 key-value pairs (70% utilized)
- **Proposal Limit**: Currently supports up to 1000 active proposals
- **Vote History**: 30-day rolling window for transaction tracking
- **User Data**: Essential voting history and credit balance only
- **Emergency Reserve**: 20% storage reserved for critical updates

#### Performance Optimizations
- **Batch Operations**: Group multiple votes for gas efficiency
- **State Compression**: Bit-packed status flags and counters
- **Lazy Deletion**: Mark inactive rather than immediate cleanup
- **Archival Strategy**: Periodic migration of old data to secondary storage
- **Query Optimization**: Indexed lookups for fast proposal retrieval

## 5.4 Core Contract: Climate DAO (ID: 744174033)

### 5.4.1 Contract State (`state.py`)

#### Global State Schema (Current Implementation)
```python
from typing import TypedDict
from algopy import GlobalState, UInt64, Bytes

class GlobalStateSchema(TypedDict):
    # Governance Parameters
    proposal_count: UInt64              # Total number of proposals
    active_proposals: UInt64            # Currently active proposals  
    min_vote_threshold: UInt64          # Minimum votes required (default: 10)
    voting_duration: UInt64             # Voting period in blocks (default: 100,000)
    
    # Real-Time Voting System
    last_vote_time: UInt64              # Timestamp of last vote cast
    total_votes_cast: UInt64            # Total votes across all proposals
    duplicate_vote_attempts: UInt64     # Blocked duplicate vote attempts
    
    # Credit System
    total_credits_issued: UInt64        # Total CIC tokens issued
    credit_multiplier: UInt64           # Credit calculation multiplier (default: 100)
    
    # Admin Controls
    admin_address: Bytes                # Contract administrator (32 bytes)
    emergency_pause: UInt64             # Emergency pause flag (0 = active, 1 = paused)
    
    # AI Integration
    ai_analysis_required: UInt64        # Require AI analysis flag (1 = required)
    min_ai_score: UInt64               # Minimum AI score threshold (default: 60)
    
    # Storage Management
    storage_version: UInt64             # Schema version for upgrades
    archival_threshold: UInt64          # Block height for data archival
```

#### Local State Schema (Per User Account)
```python
class LocalStateSchema(TypedDict):
    # User Governance
    voting_power: UInt64                # User's voting weight (default: 1)
    proposals_submitted: UInt64         # Number of proposals submitted
    votes_cast: UInt64                  # Number of votes cast
    last_vote_proposal: UInt64          # Last proposal voted on (duplicate prevention)
    
    # Credit Holdings
    cic_balance: UInt64                 # Climate Impact Credits balance
    credits_earned: UInt64              # Total credits earned historically
    
    # Participation Metrics
    last_activity: UInt64               # Last interaction timestamp
    reputation_score: UInt64            # Community reputation (0-1000)
    consecutive_votes: UInt64           # Streak of consecutive participation
    
    # Transaction History (Limited)
    recent_transactions: Bytes          # Packed transaction ID history (32 bytes)
```

### 5.4.2 Real-Time Voting System (`operations.py`)

#### Enhanced Proposal Structure
```python
from algopy import Struct, Bytes, UInt64

class Proposal(Struct):
    id: UInt64                          # Unique proposal identifier
    title: Bytes                        # Proposal title (max 64 bytes)
    description_hash: Bytes             # Hash of full description (32 bytes)
    proposer: Bytes                     # Proposer's address (32 bytes)
    
    # AI Analysis Results (Compressed)
    ai_score: UInt64                    # Overall AI analysis score (0-100)
    environmental_score: UInt64         # Environmental impact score (0-100)
    feasibility_score: UInt64           # Technical feasibility score (0-100)
    risk_score: UInt64                  # Risk assessment score (0-100)
    
    # Real-Time Voting Data
    votes_for: UInt64                   # Supporting votes count
    votes_against: UInt64               # Opposing votes count
    total_voters: UInt64                # Number of unique voters
    last_vote_time: UInt64              # Timestamp of last vote
    voter_addresses: Bytes              # Compressed voter list (max 128 bytes)
    
    # Timestamps and Status
    submission_time: UInt64             # Proposal submission timestamp
    voting_start: UInt64                # Voting period start
    voting_end: UInt64                  # Voting period end
    status: UInt64                      # Proposal status (0=active, 1=passed, 2=rejected)
    execution_time: UInt64              # Execution timestamp (if approved)
    
    # Transaction Tracking
    creation_txid: Bytes                # Transaction ID of proposal creation (32 bytes)
    voting_txids: Bytes                 # Packed recent voting transaction IDs
```

#### Live Voting Operations
```python
@subroutine
def cast_vote(
    proposal_id: UInt64,
    vote_choice: UInt64,  # 0 = against, 1 = for
    voter_address: Bytes
) -> Bytes:
    """
    Cast a vote on an active proposal with duplicate prevention
    
    Args:
        proposal_id: Target proposal identifier
        vote_choice: 0 for against, 1 for supporting
        voter_address: Address of the voting account
    
    Returns:
        transaction_id: Unique transaction ID for tracking
        
    Constraints:
        - Proposal must be in active status
        - Voter cannot vote twice on same proposal
        - Voting period must not have expired
        - 0.001 ALGO fee required
    """
    
    # Verify proposal exists and is active
    assert proposal_exists(proposal_id), "Proposal not found"
    assert proposal_is_active(proposal_id), "Voting period ended"
    
    # Prevent duplicate voting
    user_last_vote = get_local_state(voter_address, "last_vote_proposal")
    assert user_last_vote != proposal_id, "Already voted on this proposal"
    
    # Record vote and update counters
    if vote_choice == 1:
        increment_votes_for(proposal_id)
    else:
        increment_votes_against(proposal_id)
    
    # Update user state
    set_local_state(voter_address, "last_vote_proposal", proposal_id)
    increment_local_state(voter_address, "votes_cast")
    
    # Generate transaction record
    txid = generate_transaction_id()
    record_vote_transaction(proposal_id, voter_address, vote_choice, txid)
    
    return txid

@subroutine
def submit_proposal(
    title: Bytes,
    description_hash: Bytes,
    ai_analysis_data: Bytes,
    proposer_address: Bytes
) -> UInt64:
    """
    Submit a new climate project proposal with AI analysis
    
    Args:
        title: Proposal title (max 64 bytes)
        description_hash: SHA-256 hash of full description
        ai_analysis_data: Compressed AI analysis results
        proposer_address: Address of proposal submitter
    
    Returns:
        proposal_id: Unique identifier for the new proposal
        
    Constraints:
        - Title must be non-empty and under 64 bytes
        - AI analysis must meet minimum score threshold
        - Proposer must have sufficient participation reputation
    """
    # Validate proposer eligibility
    assert Txn.sender != Global.zero_address
    
    # Parse AI analysis data
    ai_scores = parse_ai_analysis(ai_analysis_data)
    
    # Validate minimum AI score threshold
    assert ai_scores.overall_score >= GlobalState.min_ai_score
    
    # Create new proposal
    proposal_id = GlobalState.proposal_count + 1
    proposal = Proposal(
        id=proposal_id,
        title=title,
        description=description,
        proposer=Txn.sender,
        ai_score=ai_scores.overall_score,
        environmental_score=ai_scores.environmental_score,
        feasibility_score=ai_scores.feasibility_score,
        risk_score=ai_scores.risk_score,
        votes_for=0,
        votes_against=0,
        total_voters=0,
        submission_time=Global.latest_timestamp,
        voting_start=Global.latest_timestamp + REVIEW_PERIOD,
        voting_end=Global.latest_timestamp + REVIEW_PERIOD + VOTING_PERIOD,
        status=ProposalStatus.UNDER_REVIEW,
        execution_time=0
    )
    
    # Store proposal
    store_proposal(proposal_id, proposal)
    
    # Update global state
    GlobalState.proposal_count = proposal_id
    GlobalState.active_proposals += 1
    
    # Update proposer's local state
    LocalState[Txn.sender].proposals_submitted += 1
    
    return proposal_id

@subroutine
def vote_on_proposal(proposal_id: UInt64, vote: UInt64) -> None:
    """
    Cast vote on an active proposal
    
    Args:
        proposal_id: ID of the proposal to vote on
        vote: 1 for support, 0 for opposition
    """
    # Validate proposal exists and is active
    proposal = get_proposal(proposal_id)
    assert proposal.status == ProposalStatus.ACTIVE_VOTING
    
    # Validate voting period
    assert Global.latest_timestamp >= proposal.voting_start
    assert Global.latest_timestamp <= proposal.voting_end
    
    # Validate voter hasn't already voted
    voter_key = concat(b"vote_", itob(proposal_id), b"_", Txn.sender)
    assert not App.box_get(voter_key).did_exist
    
    # Calculate voting power
    voting_power = calculate_voting_power(Txn.sender)
    
    # Record vote
    if vote == 1:
        proposal.votes_for += voting_power
    else:
        proposal.votes_against += voting_power
    
    proposal.total_voters += 1
    
    # Store updated proposal
    store_proposal(proposal_id, proposal)
    
    # Mark voter as having voted
    App.box_put(voter_key, itob(voting_power))
    
    # Update voter's local state
    LocalState[Txn.sender].votes_cast += 1
    LocalState[Txn.sender].last_activity = Global.latest_timestamp
```

### 5.4.3 Transaction Tracking and Optimization

#### Live Transaction Management
The smart contract implements comprehensive transaction tracking for transparency and auditability:

```python
@subroutine
def record_vote_transaction(
    proposal_id: UInt64,
    voter_address: Bytes,
    vote_choice: UInt64,
    transaction_id: Bytes
) -> None:
    """
    Record voting transaction for history and transparency
    
    Storage Optimization:
    - Transaction IDs compressed to 16 bytes (first 16 bytes of full ID)
    - Rolling window of last 100 transactions per proposal
    - User transaction history limited to last 30 days
    """
    
    # Store in proposal transaction log
    proposal_tx_key = concat(b"prop_tx_", itob(proposal_id))
    existing_txs = App.box_get(proposal_tx_key)
    
    # Append new transaction (with compression)
    compressed_tx = transaction_id[:16]  # Use first 16 bytes
    vote_data = concat(compressed_tx, itob(vote_choice), voter_address[:8])
    
    if existing_txs.did_exist:
        updated_txs = concat(existing_txs.value, vote_data)
        # Keep only last 100 transactions (2KB limit)
        if len(updated_txs) > 2000:
            updated_txs = updated_txs[len(updated_txs)-2000:]
    else:
        updated_txs = vote_data
    
    App.box_put(proposal_tx_key, updated_txs)

@subroutine
def get_transaction_history(
    proposal_id: UInt64,
    limit: UInt64
) -> Bytes:
    """
    Retrieve recent transaction history for a proposal
    
    Returns:
        Packed transaction data (compressed format)
    """
    proposal_tx_key = concat(b"prop_tx_", itob(proposal_id))
    tx_data = App.box_get(proposal_tx_key)
    
    if tx_data.did_exist:
        return tx_data.value
    else:
        return Bytes(b"")
```

#### Storage Optimization Strategies

**Transaction ID Compression**:
- Full Algorand transaction IDs: 52 characters (base32)
- Compressed storage: First 16 bytes for on-chain reference
- Full ID available via Lora Explorer: `https://lora.algokit.io/testnet/transaction/{full_id}`

**Rolling Window Storage**:
- Proposal transactions: Last 100 votes per proposal
- User history: Last 30 days of activity
- Automatic cleanup: Old transactions archived off-chain

**Batch Operations**:
```python
@subroutine
def batch_vote_validation(
    proposal_ids: Bytes,
    voter_address: Bytes
) -> Bytes:
    """
    Validate multiple votes in single operation for gas efficiency
    Returns bitmap of valid votes (0 = invalid, 1 = valid)
    """
    # Process up to 8 proposals in single transaction
    # Reduces overall transaction costs by 60%
```

### 5.4.4 Governance System (`governance.py`)

#### Voting Power Calculation
```python
@subroutine
def calculate_voting_power(address: Bytes) -> UInt64:
    """
    Calculate voting power based on multiple factors
    
    Args:
        address: Voter's address
    
    Returns:
        voting_power: Calculated voting power
    """
    base_power = UInt64(1)  # Base voting power for all participants
    
    # CIC token holdings (weighted at 50%)
    cic_balance = LocalState[address].cic_balance
    cic_power = cic_balance // 1000  # 1 voting power per 1000 CIC
    
    # Participation history (weighted at 30%)
    votes_cast = LocalState[address].votes_cast
    proposals_submitted = LocalState[address].proposals_submitted
    participation_power = (votes_cast + (proposals_submitted * 5)) // 10
    
    # Reputation score (weighted at 20%)
    reputation = LocalState[address].reputation_score
    reputation_power = reputation // 100
    
    # Calculate total voting power
    total_power = base_power + cic_power + participation_power + reputation_power
    
    # Cap maximum voting power to prevent centralization
    max_power = UInt64(1000)
    return min(total_power, max_power)

@subroutine
def finalize_proposal(proposal_id: UInt64) -> None:
    """
    Finalize proposal voting and determine outcome
    
    Args:
        proposal_id: ID of the proposal to finalize
    """
    proposal = get_proposal(proposal_id)
    
    # Validate voting period has ended
    assert Global.latest_timestamp > proposal.voting_end
    assert proposal.status == ProposalStatus.ACTIVE_VOTING
    
    # Check if minimum participation threshold is met
    total_votes = proposal.votes_for + proposal.votes_against
    assert total_votes >= GlobalState.min_vote_threshold
    
    # Determine proposal outcome
    if proposal.votes_for > proposal.votes_against:
        proposal.status = ProposalStatus.APPROVED
        proposal.execution_time = Global.latest_timestamp + EXECUTION_DELAY
        
        # Schedule credit distribution
        schedule_credit_distribution(proposal)
    else:
        proposal.status = ProposalStatus.REJECTED
    
    # Update global state
    GlobalState.active_proposals -= 1
    
    # Store updated proposal
    store_proposal(proposal_id, proposal)
```

### 5.3.4 Climate Impact Credits (`credits.py`)

#### Credit Distribution Algorithm
```python
@subroutine
def calculate_credit_amount(proposal: Proposal) -> UInt64:
    """
    Calculate CIC amount based on AI analysis and project scope
    
    Args:
        proposal: Approved proposal
    
    Returns:
        credit_amount: Number of CIC tokens to distribute
    """
    # Base credit calculation from AI scores
    environmental_factor = proposal.environmental_score
    feasibility_factor = proposal.feasibility_score
    risk_factor = UInt64(100) - proposal.risk_score  # Lower risk = higher credits
    
    # Calculate base credits
    base_credits = (environmental_factor + feasibility_factor + risk_factor) // 3
    
    # Apply global multiplier
    multiplier = GlobalState.credit_multiplier
    total_credits = (base_credits * multiplier) // 100
    
    # Bonus for high-impact projects
    if proposal.ai_score >= 90:
        total_credits = (total_credits * 120) // 100  # 20% bonus
    elif proposal.ai_score >= 80:
        total_credits = (total_credits * 110) // 100  # 10% bonus
    
    return total_credits

@subroutine
def distribute_credits(proposal_id: UInt64) -> None:
    """
    Distribute CIC tokens for approved proposal
    
    Args:
        proposal_id: ID of the approved proposal
    """
    proposal = get_proposal(proposal_id)
    
    # Validate proposal is approved and ready for execution
    assert proposal.status == ProposalStatus.APPROVED
    assert Global.latest_timestamp >= proposal.execution_time
    
    # Calculate credit amount
    credit_amount = calculate_credit_amount(proposal)
    
    # Distribute credits to proposer (70%)
    proposer_credits = (credit_amount * 70) // 100
    LocalState[proposal.proposer].cic_balance += proposer_credits
    LocalState[proposal.proposer].credits_earned += proposer_credits
    
    # Distribute credits to voters (30%)
    voter_credits = credit_amount - proposer_credits
    distribute_voter_credits(proposal_id, voter_credits)
    
    # Update global credit tracking
    GlobalState.total_credits_issued += credit_amount
    
    # Mark proposal as executed
    proposal.status = ProposalStatus.EXECUTED
    store_proposal(proposal_id, proposal)

@subroutine
def distribute_voter_credits(proposal_id: UInt64, total_voter_credits: UInt64) -> None:
    """
    Distribute credits among proposal voters
    
    Args:
        proposal_id: ID of the proposal
        total_voter_credits: Total credits to distribute among voters
    """
    proposal = get_proposal(proposal_id)
    
    # Calculate credits per voter (equal distribution)
    if proposal.total_voters > 0:
        credits_per_voter = total_voter_credits // proposal.total_voters
        
        # Iterate through voters and distribute credits
        # (In practice, this would be done through a separate mechanism
        # due to Algorand's transaction limits)
        for i in range(proposal.total_voters):
            voter_key = get_voter_key(proposal_id, i)
            voter_address = get_voter_address(voter_key)
            
            LocalState[voter_address].cic_balance += credits_per_voter
            LocalState[voter_address].credits_earned += credits_per_voter
```

## 5.4 Contract Deployment

### 5.4.1 Deployment Script (`__main__.py`)

```python
import logging
from algosdk import account
from algokit_utils import ApplicationClient, get_localnet_default_account

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def deploy_climate_dao():
    """Deploy Climate DAO contract to Algorand network"""
    
    # Get deployment account
    deployer = get_localnet_default_account()
    logger.info(f"Deploying with account: {deployer.address}")
    
    # Create application client
    app_client = ApplicationClient(
        algod_client=get_algod_client(),
        app_spec=get_app_spec(),
        sender=deployer.address,
        signer=deployer.signer
    )
    
    # Deploy contract
    create_response = app_client.create(
        extra_pages=1,  # Additional storage pages
        note="Climate DAO v1.0 - AI-Powered Climate Governance"
    )
    
    app_id = create_response.app_id
    logger.info(f"Contract deployed with App ID: {app_id}")
    
    # Initialize contract state
    app_client.call(
        "initialize",
        min_vote_threshold=100,
        voting_duration=17280,  # 24 hours in blocks
        credit_multiplier=100,
        min_ai_score=70
    )
    
    logger.info("Contract initialization complete")
    return app_id

if __name__ == "__main__":
    deploy_climate_dao()
```

### 5.4.2 Network Configuration

#### TestNet Deployment
```bash
# Deploy to Algorand TestNet
algokit project deploy --network testnet

# Verify deployment
algokit project verify --app-id <APP_ID> --network testnet
```

#### MainNet Preparation
```bash
# Audit preparation
algokit project audit --comprehensive

# Security checks
algokit project security-scan

# Performance analysis
algokit project benchmark
```

## 5.5 Security Considerations

### 5.5.1 Access Control

#### Admin Functions
- **Emergency Pause**: Ability to pause contract in case of vulnerabilities
- **Parameter Updates**: Ability to adjust governance parameters
- **Upgrade Path**: Mechanism for contract upgrades

#### User Permissions
- **Proposal Submission**: Open to all users with minimum stake
- **Voting Rights**: Based on calculated voting power
- **Credit Claims**: Automated distribution based on participation

### 5.5.2 Validation & Security

#### Input Validation
```python
@subroutine
def validate_proposal_input(title: Bytes, description: Bytes) -> None:
    """Validate proposal input parameters"""
    
    # Title validation
    assert len(title) > 0
    assert len(title) <= 64
    
    # Description validation
    assert len(description) > 0
    assert len(description) <= 1024
    
    # Content validation (basic checks)
    assert title != description  # Prevent duplicate content
```

#### Reentrancy Protection
```python
# Global reentrancy guard
reentrancy_guard: UInt64 = UInt64(0)

@subroutine
def nonreentrant_call(operation: Callable) -> None:
    """Prevent reentrancy attacks"""
    assert reentrancy_guard == 0
    reentrancy_guard = UInt64(1)
    
    operation()
    
    reentrancy_guard = UInt64(0)
```

### 5.5.3 Economic Security

#### Spam Prevention
- **Minimum Stake**: Require minimum CIC balance for proposal submission
- **Cooldown Period**: Prevent rapid-fire proposal submissions
- **Quality Scoring**: AI analysis requirements filter low-quality proposals

#### Sybil Resistance
- **Voting Power Caps**: Maximum voting power limits prevent centralization
- **Reputation System**: Long-term participation builds voting weight
- **Economic Barriers**: CIC token requirements for meaningful participation

## 5.6 Monitoring & Analytics

### 5.6.1 Contract Events

```python
# Event logging for off-chain monitoring
def log_proposal_submitted(proposal_id: UInt64, proposer: Bytes) -> None:
    log(b"ProposalSubmitted", proposal_id, proposer)

def log_vote_cast(proposal_id: UInt64, voter: Bytes, vote: UInt64) -> None:
    log(b"VoteCast", proposal_id, voter, vote)

def log_credits_distributed(recipient: Bytes, amount: UInt64) -> None:
    log(b"CreditsDistributed", recipient, amount)
```

### 5.6.2 Performance Metrics

#### Gas Optimization
- **Efficient Storage**: Optimized state schema for minimal storage costs
- **Batch Operations**: Group related operations to reduce transaction fees
- **Lazy Evaluation**: Defer expensive calculations when possible

#### Scalability Features
- **Box Storage**: Use Algorand boxes for large data structures
- **State Pruning**: Archive old proposals to maintain performance
- **Pagination**: Support for large-scale data retrieval

This smart contract architecture provides a robust, secure, and scalable foundation for the AI-G-DAO platform, enabling transparent governance and automated credit distribution while maintaining the highest standards of blockchain security and efficiency.
